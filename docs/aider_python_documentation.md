# Aider: AI Pair Programming in Your Terminal

## Overview

Aider is a command-line tool that brings AI pair programming directly to your terminal. It allows you to chat with AI models like OpenAI's GPT models and Anthropic's Claude models to make edits to your codebase, explain code, fix bugs, generate new features, and more.

## Installation

There are several ways to install Aider:

### Easy One-Liner (Mac & Linux):
```bash
curl -s https://aider.chat/install.sh | sh
```

Or with wget:
```bash
wget -qO- https://aider.chat/install.sh | sh
```

### Using pip:
```bash
python -m pip install aider-install
aider-install
```

### Optional Dependencies

For voice coding support, install PortAudio:

Mac:
```bash
brew install portaudio
```

Ubuntu/Debian:
```bash
sudo apt-get install libportaudio2
sudo apt install libasound2-plugins
```

## Getting Started

Navigate to your project directory and run Aider:

```bash
# Change directory into your codebase
cd /to/your/project

# OpenAI models
aider --model o3-mini --api-key openai=<key>
aider --model gpt-4o --api-key openai=<key>

# Anthropic Claude models
aider --model sonnet --api-key anthropic=<key>
aider --model opus --api-key anthropic=<key>

# DeepSeek models
aider --model deepseek --api-key deepseek=<key>
```

You can also specify files to edit:

```bash
aider <file1> <file2> ...
```

## Supported Models

Aider supports multiple AI models from various providers:

### OpenAI
- o3-mini (GPT-3.5)
- o1-mini (GPT-4o Mini)
- gpt-4o (GPT-4o)
- Many others

### Anthropic
- claude-3-sonnet-20240229 (Sonnet)
- claude-3-opus-20240229 (Opus)
- claude-3.5-sonnet-20240620 (Sonnet 3.5)
- claude-3.7-sonnet (Sonnet 3.7)

### DeepSeek
- deepseek-chat
- deepseek-coder

### Cohere
- command-r-plus-08-2024

### Other Providers
- OpenRouter compatible models
- Others through OpenAI compatible APIs

You can list all available models:
```bash
aider --list-models openai/
aider --list-models anthropic/
aider --list-models cohere_chat/
```

## Core Features

### AI Pair Programming

Aider allows you to describe changes you want to make to your code in natural language, and the AI will implement the changes for you:

```
> Add a factorial endpoint that uses math.factorial
```

### Code Understanding and Explanation

Aider can explain existing code and help you understand how it works:

```
> Explain how the Ball class handles collisions
```

### Git Integration

Aider automatically commits changes to your Git repository with meaningful commit messages generated by the AI. Features include:

- Auto-commits of AI changes
- Dirty commits when the repository has uncommitted changes
- Attribution of AI changes in Git author/committer names
- Support for Git pre-commit hooks

### Voice Coding

Aider supports voice commands with the `/voice` chat command, allowing you to speak your coding instructions.

### Linting and Testing

Aider can automatically lint your code after changes and run tests:

```bash
# Enable automatic linting
aider --auto-lint

# Specify lint commands for different languages
aider --lint-cmd "python: flake8 --select=..." --lint-cmd "js: eslint"

# Enable automatic testing
aider --auto-test --test-cmd "pytest"
```

## Usage Modes

### Interactive Chat

By default, Aider runs in an interactive chat mode where you can have a conversation with the AI about your code.

### Single-Message Mode

You can run Aider with a single message, have it make changes, and exit:

```bash
aider --message "add descriptive docstrings to all the functions" file.py
```

### Batch Processing

You can use Aider for batch processing multiple files:

```bash
for FILE in *.py ; do
    aider --message "add descriptive docstrings to all the functions" $FILE
done
```

### Browser UI

Aider supports a browser-based UI:

```bash
aider --browser
```

## Advanced Features

### Repository Map

Aider creates a map of your repository to give the AI context about your codebase:

```bash
# Control repo map creation
aider --map-tokens 2048 --map-refresh auto
```

### Architect Mode

Architect mode provides a specialized way for the AI to analyze and make changes to your code:

```bash
aider --architect
```

### Programming with Aider's Python API

You can use Aider programmatically in Python scripts:

```python
from aider.coders import Coder
from aider.models import Model

# Files to add to the chat
fnames = ["example.py"]

model = Model("gpt-4o")

# Create a coder object
coder = Coder.create(main_model=model, fnames=fnames)

# Execute an instruction on those files
coder.run("make a script that prints hello world")

# Send another instruction
coder.run("make it say goodbye")

# Run in-chat "/" commands
coder.run("/tokens")
```

## Configuration

Aider can be configured in several ways:

### Environment Variables

```bash
export OPENAI_API_KEY=<key>
export ANTHROPIC_API_KEY=<key>
```

### .env File

Create a `.env` file in your project root:

```bash
OPENAI_API_KEY=<key>
ANTHROPIC_API_KEY=<key>
```

### YAML Configuration

Create a `.aider.conf.yml` file in your home directory or project root:

```yaml
openai-api-key: <key>
anthropic-api-key: <key>
model: gpt-4o
auto-commits: true
```

### Command-Line Arguments

```bash
aider --model gpt-4o --api-key openai=<key> --auto-commits
```

## Edit Formats

Aider supports different code edit formats:

### Diff Edit Format

The diff edit format uses a search and replace pattern:

```
filename.py
<<<<<<< SEARCH
def greeting():
    print("Hello")
=======
def greeting():
    print("Goodbye")
>>>>>>> REPLACE
```

### JSON Edit Format

Structured JSON format for code edits:

```json
{
    "filename": "greeting.py",
    "search": "def greeting():\n    print(\"Hello\")\n",
    "replace": "def greeting():\n    print(\"Goodbye\")\n"
}
```

### Whole-Function Edit Format

Returns the entire updated file content.

## Commands

Aider supports various chat commands:

- `/help` - Show help about chat commands
- `/add <file>...` - Add files to the chat session
- `/drop <file>...` - Remove files from the chat session
- `/ls` - List files in the chat session
- `/tokens` - Show token usage statistics
- `/clear` - Clear the chat history
- `/voice` - Record and transcribe voice input
- `/commit` - Commit all changes
- `/exit` - Exit the chat

## Best Practices

1. **Start with small, focused tasks**: Ask for one change at a time.
2. **Be specific**: Clearly describe what you want to change and why.
3. **Use Git**: Aider works best with Git repositories.
4. **Verify changes**: Always review the AI's changes before accepting them.
5. **Explore different models**: Different models have different strengths.

## Use Cases

- **Code generation**: Creating new functions, classes, or modules
- **Bug fixing**: Identifying and fixing bugs in your code
- **Refactoring**: Restructuring code without changing its behavior
- **Documentation**: Adding comments and docstrings
- **Testing**: Generating unit tests for your code
- **Learning**: Understanding how code works through explanations

## Troubleshooting

### API Key Issues

If you're having trouble with API keys, check:
- Key is correctly set in environment variables or config files
- API key has not expired
- You have sufficient credits/quota with the API provider

### Model Selection Issues

If the model isn't working as expected:
- Use `--list-models` to see available models
- Try a different model
- Ensure you're using the correct model name format

### Edit Format Issues

If code edits are not applying correctly:
- Try a different edit format with `--edit-format`
- Check that the AI is generating valid edit blocks
- For complex changes, try architect mode with `--architect`

## Examples

### Creating a Flask Endpoint

```
$ aider app.py

> Add a factorial endpoint that uses math.factorial

I'll add a factorial endpoint to your Flask application that uses the math.factorial function.

First, I need to add the import for the math module, and then create the endpoint.

app.py
<<<<<<< SEARCH
from flask import Flask

app = Flask(__name__)
=======
from flask import Flask
import math

app = Flask(__name__)
>>>>>>> REPLACE

app.py
<<<<<<< SEARCH
@app.route('/hello')
def hello():
    return "Hello, World!"

if __name__ == '__main__':
=======
@app.route('/hello')
def hello():
    return "Hello, World!"

@app.route('/fact/<int:x>')
def factorial(x):
    if x < 0:
        return "Error: Cannot calculate factorial of a negative number"
    result = math.factorial(x)
    return str(result)

if __name__ == '__main__':
>>>>>>> REPLACE
```

### Building a Pong Game

```
$ aider pong.py

> Create a simple Pong game using Pygame

I'll help you create a simple Pong game using Pygame. Here's the implementation:

pong.py
<<<<<<< SEARCH
=======
import pygame
import sys
import random

# Initialize Pygame
pygame.init()

# Set up the game window
screen_width = 640
screen_height = 480
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption("Pong")

# Paddle and Ball classes
class Paddle(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.width = 10
        self.height = 60
        self.image = pygame.Surface((self.width, self.height))
        self.image.fill((255, 255, 255))
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

    def move(self, dy):
        if self.rect.y + dy >= 0 and self.rect.y + dy <= screen_height - self.height:
            self.rect.y += dy

class Ball(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.width = 10
        self.height = 10
        self.image = pygame.Surface((self.width, self.height))
        self.image.fill((255, 255, 255))
        self.rect = self.image.get_rect()
        self.rect.x = screen_width // 2 - self.width // 2
        self.rect.y = screen_height // 2 - self.height // 2
        self.dx = random.choice([-1, 1]) * 4
        self.dy = random.choice([-1, 1]) * 4

    def update(self):
        self.rect.x += self.dx
        self.rect.y += self.dy

        # Collision with top and bottom
        if self.rect.y <= 0 or self.rect.y >= screen_height - self.height:
            self.dy = -self.dy

        # Scoring
        if self.rect.x <= 0 or self.rect.x >= screen_width - self.width:
            self.reset()

    def reset(self):
        self.rect.x = screen_width // 2 - self.width // 2
        self.rect.y = screen_height // 2 - self.height // 2
        self.dx = random.choice([-1, 1]) * 4
        self.dy = random.choice([-1, 1]) * 4

    def collide_with(self, paddle):
        if self.rect.colliderect(paddle.rect):
            self.dx = -self.dx

# Initialize paddles and ball
left_paddle = Paddle(10, screen_height // 2 - 30)
right_paddle = Paddle(screen_width - 20, screen_height // 2 - 30)
ball = Ball()

# Game loop
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # Handle user input
    keys = pygame.key.get_pressed()
    if keys[pygame.K_w]:
        left_paddle.move(-5)
    if keys[pygame.K_s]:
        left_paddle.move(5)
    if keys[pygame.K_UP]:
        right_paddle.move(-5)
    if keys[pygame.K_DOWN]:
        right_paddle.move(5)

    # Update game objects
    ball.update()
    ball.collide_with(left_paddle)
    ball.collide_with(right_paddle)

    # Draw game objects
    screen.fill((0, 0, 0))
    screen.blit(left_paddle.image, left_paddle.rect)
    screen.blit(right_paddle.image, right_paddle.rect)
    screen.blit(ball.image, ball.rect)

    # Update the display
    pygame.display.flip()
    pygame.time.delay(16)

# Quit Pygame
pygame.quit()
sys.exit()
>>>>>>> REPLACE
```
